#pragma once

#include <podrm/span.hpp>

#include <cstddef>
#include <cstdint>
#include <optional>
#include <string>
#include <string_view>
#include <variant>
#include <vector>

namespace podrm {

/// Identifier mode
enum class IdMode : std::uint8_t {
  Auto,   ///< Automatically generated by database
  Manual, ///< Provided when persisting
};

using AsImage = std::variant<span<const std::byte>, double,
                             std::vector<std::byte>, std::string_view,
                             std::string, std::uint64_t, std::int64_t, bool>;

using FromImage = std::variant<span<const std::byte>, double, std::string_view,
                               std::uint64_t, std::int64_t, bool>;

enum class ImageType {
  Int,
  Uint,
  Float,
  String,
  Bool,
  Bytes,
};

using AsImageUntyped = AsImage (*)(const void *value);
using FromImageUntyped = void (*)(const FromImage image, void *value);

struct ForeignKeyDescription {
  std::string_view entity;
  std::string_view field;
};

struct PrimitiveFieldDescription {
  ImageType imageType;
  AsImageUntyped asImage;
  FromImageUntyped fromImage;
  std::optional<ForeignKeyDescription> foreignKeyContraint;
};

struct FieldDescription;

struct CompositeFieldDescription {
  span<const FieldDescription> fields;
};

using MemberPtrFn = void *(*)(void *);
using ConstMemberPtrFn = const void *(*)(const void *);

struct FieldDescription {
  std::string_view name;

  MemberPtrFn memberPtr;
  ConstMemberPtrFn constMemberPtr;

  std::variant<PrimitiveFieldDescription, CompositeFieldDescription> field;
};

struct EntityDescription {
  IdMode idMode;
  std::string_view name;
  span<const FieldDescription> fields;
  std::size_t primaryKey;
};

template <typename Entity>
constexpr std::optional<EntityDescription> DatabaseEntityDescription =
    std::nullopt;

template <typename Entity> struct PrimaryKey {};

template <typename Entity> using PrimaryKeyType = PrimaryKey<Entity>::Type;

template <typename Entity>
constexpr std::string_view PrimaryKeyName = PrimaryKey<Entity>::Name;

template <typename Entity>
concept DatabaseEntity =
    DatabaseEntityDescription<Entity>.has_value() &&
    std::is_convertible_v<decltype(PrimaryKeyName<Entity>), std::string_view> &&
    requires { typename PrimaryKeyType<Entity>; };

} // namespace podrm
